{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/mocking-modules-with-jest","result":{"data":{"post":{"__typename":"MdxPost","slug":"/mocking-modules-with-jest","title":"Mocking modules with Jest","date":"07.03.2020","tags":null,"description":null,"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Mocking modules with Jest\",\n  \"date\": \"2020-03-07T00:00:00.000Z\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Jest is a great tool for adding confidence in our codebase, primarily by unit testing our implementation. It provides a wide range of functionality to simplify the tests we write. \"), mdx(\"p\", null, \"A common case when unit testing our modules, is mocking external dependencies of tested modules. This is where \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"jest.mock(...)\"), \" comes in the scene by doing exactly that. This is great for globally mocking these dependencies in our testing file.\"), mdx(\"p\", null, \"Something that is not really straight forward is how to manually mock module dependencies for each separate test.\"), mdx(\"p\", null, \"To better illustrate this, imagine having a module \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"A.js\"), \" depending on another module \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"B.js\"), \" as follows:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js:title=A.js\"\n  }), \"import { someFunctionB } from './B.js';\\n\\nfunction someFunctionA() {\\n  if(someFunctionB()) {\\n    return `someFunctionA + someFunctionB`;\\n  }\\n  return 'someFunctionA';\\n}\\n\\nexport { someFunctionA };\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js:title=B.js\"\n  }), \"function someFunctionB() {\\n  return true;\\n}\\n\\nexport { someFunctionB };\\n\")), mdx(\"p\", null, \"There are different approaches to mocking module dependencies. Let's see some of them based on the example above and when each of these is the best option. But first lets start with the case when we don't mock any external dependency.\"), mdx(\"br\", null), mdx(\"h3\", null, mdx(\"strong\", {\n    parentName: \"h3\"\n  }, \"No mock\")), mdx(\"br\", null), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js:title=A.test.js\"\n  }), \"import { someFunctionA } from './A.js';\\n\\ndescribe('someFunctionA', () => {\\n    it('should retrun a combined string', () => {\\n        expect(someFunctionA()).toEqual('A');\\n    });\\n});\\n\")), mdx(\"p\", null, \"When we don't apply any mock for the someFunctionB function, the actual function is getting triggered. That way, our test depends on the result of the actual implementation of that function. We don't really want to keep this behaviour for unit testing our module. This would be a good practice in case we wanted to test the result of integrating those two modules.\"), mdx(\"br\", null), mdx(\"h3\", null, mdx(\"strong\", {\n    parentName: \"h3\"\n  }, \"Global mock (default)\")), mdx(\"br\", null), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js:title=A.test.js\"\n  }), \"import { someFunctionA } from './A.js';\\n\\njest.mock('./B');\\n\\ndescribe('someFunctionA', () => {\\n    it('should return a simple string', () => {\\n        expect(someFunctionA()).toEqual('someFunctionA');\\n    });\\n});\\n\")), mdx(\"p\", null, \"By using jest.mock for the dependencies of the tested module, Jest will enable auto-mocking for the dependency module. In that case, the module implementation is replaced by default mocks. In this specific example \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"someFunctionB\"), \" from auto-mocked module \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"B.js\"), \" will be replaced with a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"jest.fn()\"), \" which returns an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"undefined\"), \" value. You can find more information about auto-mocking Jest feature \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://jestjs.io/docs/en/jest-object#jestenableautomock\"\n  }), \"here\"), \".\"), mdx(\"br\", null), mdx(\"h3\", null, mdx(\"strong\", {\n    parentName: \"h3\"\n  }, \"Global mock (explicit implementation)\")), mdx(\"br\", null), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js:title=A.test.js\"\n  }), \"import { someFunctionA } from './A.js';\\n\\njest.mock('./B', () => ({\\n    someFunctionB: () => false\\n}));\\n\\ndescribe('someFunctionA', () => {\\n    it('should return a simple string', () => {\\n        expect(someFunctionA()).toEqual('someFunctionA');\\n    });\\n});\\n\")), mdx(\"p\", null, \"There are cases when Jest auto-mocking feature is not enough, and we need to explicitly mock the implementation of the module. The above approach is good enough as far as the mocked implementation covers all our test cases. But what happens when we need an explicit mocked implementation for each of our tests?\"), mdx(\"br\", null), mdx(\"h3\", null, mdx(\"strong\", {\n    parentName: \"h3\"\n  }, \"Explicit mock\")), mdx(\"br\", null), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js:title=A.test.js\"\n  }), \"import { someFunctionA } from './A.js';\\nimport { someFunctionB } from './B.js';\\n\\njest.mock('./B');\\n    \\ndescribe('someFunctionA', () => {\\n    it('should return a simple string if someFunctionB is false', () => {\\n        someFunctionB.mockImplementation(jest.fn().mockReturnValueOnce(false));\\n        \\n        const returnA = someFunctionA();\\n        expect(someFunctionB).toHaveBeenCalledTimes(1);\\n        expect(returnA).toEqual('someFunctionA');\\n        someFunctionB.mockClear();\\n    });\\n\\n    it('should return a simple string if someFunctionB is true', () => {\\n        someFunctionB.mockImplementation(jest.fn().mockReturnValueOnce(true));\\n        \\n        const returnA = someFunctionA();\\n        expect(someFunctionB).toHaveBeenCalledTimes(1);\\n        expect(returnA).toEqual('someFunctionA + someFunctionB');\\n        someFunctionB.mockClear();\\n    });\\n});\\n\")), mdx(\"p\", null, \"To explicitly test our module based on specific module dependency results, we need to:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"auto-mock the module imported\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"import the function we need to mock from that module\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"in each of the depending tests\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"3.1. mock the function with an explicit mocked implementation\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"3.2. clear the mock for not affecting next tests\"))), mdx(\"p\", null, \"To add a mock function implementation for each of our tests we are using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mockImplementation\"), \". We explicitly define the dependent module implementation and its return value. This will also affect the result of the actual tested module. As result, we can test our module based on all the possible result combinations of its dependencies. You can learn more about \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mockImplementation\"), \" \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://jestjs.io/docs/en/mock-function-api#mockfnmockimplementationfn\"\n  }), \"here\"), \".\"), mdx(\"p\", null, \"A common pitfall is that our mocks need to be in a clean state after each test is run. As a result, we need to clear these mocks at the end of each test, so as our tests are not affected from one another.\"), mdx(\"p\", null, \"As we can see there is not a silver bullet of mocking a dependency of a module while unit testing it. Each mocking strategy above covers a different test case. We should be aware of what we want our tests to achieve and select the best option based on these needs.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Jest is a great tool for adding confidence in our codebase, primarily by unit testing our implementation. It provides a wide range ofâ€¦","timeToRead":2,"banner":null}},"pageContext":{"slug":"/mocking-modules-with-jest","formatString":"DD.MM.YYYY"}}}